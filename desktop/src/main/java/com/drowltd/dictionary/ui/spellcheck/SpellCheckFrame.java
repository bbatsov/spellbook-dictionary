/*
 * SpellCheckFrame.java
 *
 * Created on Nov 25, 2009, 6:53:41 PM
 */
package com.drowltd.dictionary.ui.spellcheck;

import com.drowltd.dictionary.core.i18n.Translator;
import com.drowltd.dictionary.core.spellcheck.SpellChecker;
import java.awt.EventQueue;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.AdjustmentEvent;
import java.awt.event.AdjustmentListener;
import java.awt.event.MouseEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.util.Map;
import java.util.prefs.Preferences;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.accessibility.AccessibleEditableText;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTextPane;
import javax.swing.JViewport;
import javax.swing.ProgressMonitor;
import javax.swing.Timer;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.BadLocationException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 *
 * @author iivalchev
 */
public class SpellCheckFrame extends javax.swing.JFrame implements PropertyChangeListener {

    private static final SpellCheckFrame INSTANCE = new SpellCheckFrame();
    private static final Logger LOGGER = LoggerFactory.getLogger(SpellCheckFrame.class);
    private static final Translator TRANSLATOR = Translator.getTranslator("SpellbookForm");
    private final MisspelledWordsRegistry registry = MisspelledWordsRegistry.getInstance();
    private SpellCheckPopupMenu popupMenu;
    private SpellCheckHighlighter checkHighlighter;
    private SpellChecker spellChecker;
    private ProgressMonitor progressMonitor;
    private SpellCheckerLoadingWorker operation;
    private Timer documentChangedTimer;
    private Timer adjustmentValueTimer;
    private final int INTERVAL = 550;

    public static SpellCheckFrame getInstance() {
        return INSTANCE;
    }

    /** Creates new form SpellCheckFrame */
    private SpellCheckFrame() {
        initComponents();
        init();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane = new javax.swing.JScrollPane();
        jTextPane = new javax.swing.JTextPane();

        jTextPane.setBackground(java.awt.Color.white);
        jTextPane.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTextPaneMouseClicked(evt);
            }
        });
        jScrollPane.setViewportView(jTextPane);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 499, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 481, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jTextPaneMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTextPaneMouseClicked
        if (evt.getButton() == MouseEvent.BUTTON3) {
            popupMenu.show(evt);
        }
        //popupMenu.show(evt);
    }//GEN-LAST:event_jTextPaneMouseClicked
    /**
     * @param args the command line arguments
     */
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane;
    private javax.swing.JTextPane jTextPane;
    // End of variables declaration//GEN-END:variables

    /**
     * Custom initializations.
     */
    private void init() {

        jScrollPane.getVerticalScrollBar().addAdjustmentListener(new AdjustmentListener() {

            @Override
            public void adjustmentValueChanged(AdjustmentEvent e) {
                jScrollPaneAdjustmentValueChanged(e);
            }
        });

        jTextPane.getDocument().addDocumentListener(new DocumentListener() {

            @Override
            public void insertUpdate(DocumentEvent e) {
                triggerMisspelledSearch(documentChangedTimer, true);
            }

            @Override
            public void removeUpdate(DocumentEvent e) {
                triggerMisspelledSearch(documentChangedTimer, true);
            }

            @Override
            public void changedUpdate(DocumentEvent e) {
                triggerMisspelledSearch(documentChangedTimer, true);
            }
        });

        EventQueue.invokeLater(new Runnable() {

            @Override
            public void run() {
                popupMenu = SpellCheckPopupMenu.init(SpellCheckFrame.getInstance());
                checkHighlighter = SpellCheckHighlighter.init(jTextPane.getHighlighter());
                loadSpellChecker();
            }
        });

        documentChangedTimer = new Timer(INTERVAL, new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                documentChangedTimer.stop();
                MisspelledFinder.getInstance().findMisspelled(getVisibleText());
            }
        });

        adjustmentValueTimer = new Timer(INTERVAL, new ActionListener() {

            @Override
            public void actionPerformed(ActionEvent e) {
                adjustmentValueTimer.stop();
                MisspelledFinder.getInstance().findMisspelled(getVisibleText());
            }
        });

    }

    private void triggerMisspelledSearch(Timer timer, boolean removeHighlightOnCaret) {
        if (timer == null) {
            return;
        }

        if (removeHighlightOnCaret) {
            checkHighlighter.removeHighlight(jTextPane.getCaretPosition(), jTextPane.getCaretPosition());
        }

        if (timer.isRunning()) {
            timer.restart();
        } else {
            timer.start();
        }
    }

    private void jScrollPaneAdjustmentValueChanged(AdjustmentEvent e) {

        if (e.getValueIsAdjusting() || documentChangedTimer.isRunning() || jTextPane.getSelectedText() != null) {
            return;
        }

        triggerMisspelledSearch(adjustmentValueTimer, false);
    }

    /**
     * Creates and starts the SpellCheckerLoadingWorker responisble for
     * creating a Map<String, Integer> object needed by the SpellChecker.
     *
     */
    private void loadSpellChecker() {
        Preferences prefs = Preferences.userNodeForPackage(this.getClass());
        while (true) {
            if (verifySpellFilePresense(prefs)) {
                break;
            }
        }
        progressMonitor = new ProgressMonitor(this, "Getting Smart", "", 0, 100);
        progressMonitor.setProgress(0);

        operation = new SpellCheckerLoadingWorker(this, prefs.get("PATH_TO_SF", ""));
        operation.addPropertyChangeListener(this);
        operation.execute();

    }

    /**
     * Callback method invoked by the SpellCheckerLoadingWorker.
     *
     * @param nWords sets the Map<String, Integer> needed by the SpellChecker
     */
    synchronized void initSpellChecker(Map<String, Integer> nWords) {
        if (nWords == null) {
            LOGGER.error("nWords is null");
            throw new NullPointerException("nWords is null");
        }
        if (nWords.isEmpty()) {
            LOGGER.error("nWords is empty");
            throw new IllegalArgumentException("nWords is empty");
        }
        spellChecker = new SpellChecker(nWords);
        MisspelledFinder.getInstance().setSpellChecker(spellChecker);
        popupMenu.setSpellChecker(spellChecker);
    }

    /**
     * The implementation of PropertyChangeListner interface.
     * Listens for PropertyChangeEvents on the SpellCheckerLoadingWorker and
     * update the ProgressMonitor.
     *
     * @param event
     */
    @Override
    public void propertyChange(PropertyChangeEvent event) {
        if (progressMonitor.isCanceled()) {
            operation.cancel(true);
        } else if (event.getPropertyName().equals("progress")) {
            int progress = ((Integer) event.getNewValue()).intValue();
            progressMonitor.setProgress(progress);
        }

    }

    /**
     * Gets the currently visible text in the jTextPane.
     *
     * @return VisibleText repersentig currently visible text
     */
    public VisibleText getVisibleText() {
        int offset = 0;
        int length = 0;

        JViewport viewPort = (JViewport) jTextPane.getParent();
        offset = jTextPane.viewToModel(viewPort.getViewRect().getLocation());

        LOGGER.info("offset: " + offset);
        int x = (int) viewPort.getViewRect().getWidth();
        int y = (int) viewPort.getVisibleRect().getHeight();

        Point endPoint = new Point(x, y);
        length = jTextPane.viewToModel(endPoint);

        LOGGER.info("length: " + length);

        final int actualLength = jTextPane.getDocument().getLength();

        if ((offset + length) > actualLength) {
            length = actualLength - offset;
        }

        try {
            return new VisibleText(jTextPane.getText(offset, length), offset);
        } catch (BadLocationException ex) {
            LOGGER.error(ex.getMessage() + " offset: " + offset + " length: " + length + " text length: " + jTextPane.getDocument().getLength());
            throw new IllegalStateException(ex.getMessage());
        }
    }

    public void correct(String correction, MisspelledWord misspelledWord, int cursorPosition) {
        if (correction == null) {
            LOGGER.error("correction is null");
            throw new NullPointerException("correction is null");
        }

        if (correction.isEmpty()) {
            LOGGER.error("correction is empty");
            throw new IllegalArgumentException("correction is empty");
        }

        if (misspelledWord == null) {
            LOGGER.error("misspelledWord is null");
            throw new NullPointerException("misspelledWord is null");
        }

        if (cursorPosition < 0) {
            LOGGER.error("cursorPosition < 0");
            throw new IllegalArgumentException("cursorPosition < 0");
        }

        //@todo Extract Method
        if (Character.isUpperCase(misspelledWord.getWord().charAt(0))) {
            if (misspelledWord.getWord().equals(misspelledWord.getWord().toUpperCase())) {
                correction = correction.toUpperCase();
            } else {
                correction = Character.toUpperCase(correction.charAt(0)) + correction.substring(1);
            }
        }

        final AccessibleEditableText editableText = jTextPane.getAccessibleContext().getAccessibleEditableText();

        Pattern p = Pattern.compile("\\b" + misspelledWord.getWord() + "\\b");
        do {
            Matcher m = p.matcher(jTextPane.getText());
            if (!m.find()) {
                break;
            }
            String misspelled = m.group();
            int end = m.end();
            int start = end - (misspelled.length());

            checkHighlighter.removeHighlight(start, end);
            editableText.replaceText(start, end, correction);

        } while (true);

        if (cursorPosition > -1) {
            jTextPane.setCaretPosition(cursorPosition);
        }

        synchronized (registry) {
            registry.corrected(misspelledWord);
        }

        MisspelledFinder.getInstance().findMisspelled(SpellCheckFrame.getInstance().getVisibleText());
    }

    JTextPane getjTextPane() {
        return jTextPane;
    }

    //Duplicated code
    //@todo Need to be fixed with correct translations !
    /**
     *
     * @param prefs
     * @return
     */
    private boolean verifySpellFilePresense(Preferences prefs) {

        if (prefs == null) {
            LOGGER.error("prefs is null");
            throw new NullPointerException("prefs is null");
        }

        final String sfPath = prefs.get("PATH_TO_SF", "");
        File file = new File(sfPath);
        if (!file.exists()) {
            if (sfPath.isEmpty()) {
                //JOptionPane.showMessageDialog(this, TRANSLATOR.translate("SelectDb(Message)"));
                JOptionPane.showMessageDialog(this, "Path to big.txt");
            } else {
                //JOptionPane.showMessageDialog(this, TRANSLATOR.translate("MissingDb(Message)"));
                JOptionPane.showMessageDialog(this, "Path to big.txt");
            }

            JFileChooser fileChooser = new JFileChooser();
            final int result = fileChooser.showDialog(this, TRANSLATOR.translate("SelectDb(Title)"));

            if (result == JFileChooser.APPROVE_OPTION) {
                String selectedSfPath = fileChooser.getSelectedFile().getPath();

                if (selectedSfPath.endsWith("big.txt")) {
                    prefs.put("PATH_TO_SF", selectedSfPath);
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * Represents a visble text.
     */
    public static class VisibleText {

        private String text;
        private int offset;

        public VisibleText(String text, int offset) {
            if (text == null) {
                LOGGER.error("text is null");
                throw new NullPointerException("text is null");
            }

            if (offset < 0) {
                LOGGER.error("offset is < 0");
                throw new IllegalArgumentException("offset is < 0");
            }

            this.text = text;
            this.offset = offset;
        }

        public int getOffset() {
            return offset;
        }

        public String getText() {
            return text;
        }
    }
}
